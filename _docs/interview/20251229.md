20251229

15:00～15:45: 京东酒旅

为什么要面试、了解面试的岗位吗，之前主要是偏低层、中台，这个岗位是面向C端的，有什么想法

聊项目，主要聊UI自动化



抢茅台、秒杀场景有哪些技术难点，怎么解决

怎么应对黄牛刷单？

> ## 一、秒杀场景的核心技术难点
>
> ### 1. **高并发流量冲击**
>
> - 秒杀开始瞬间，大量用户同时请求，QPS 可能高达数十万甚至百万级。
> - 后端服务、数据库、缓存等容易成为瓶颈，导致系统雪崩。
>
> ### 2. **超卖问题（库存一致性）**
>
> - 多个请求同时读取库存并扣减，若不加控制，会导致实际卖出数量 > 库存数量。
> - 涉及分布式环境下的数据一致性保障。
>
> ### 3. **数据库压力过大**
>
> - 直接操作数据库扣库存，在高并发下极易造成数据库连接耗尽、响应变慢甚至宕机。
>
> ### 4. **恶意请求与刷单**
>
> - 用户使用脚本、机器人频繁刷新或提前抢购，破坏公平性。
> - 需要识别并拦截异常流量。
>
> ### 5. **用户体验与响应速度**
>
> - 用户希望“点击即得”，但系统若处理缓慢，会引发大量重试，进一步加剧系统压力。
>
> ### 6. **热点数据与缓存击穿/穿透/雪崩**
>
> - 秒杀商品信息、库存等为热点数据，缓存设计不当易引发缓存问题。
>
> ------
>
> ## 二、解决方案详解（结合 Java 技术栈）
>
> ### 1. **流量削峰与限流**
>
> - **前端限流**：按钮置灰、倒计时、验证码（图形/滑块）、答题等，延迟真实请求到达后端。
> - **网关层限流**：使用 Spring Cloud Gateway / Nginx + Lua / Sentinel 实现令牌桶/漏桶限流。
> - **服务降级**：非核心功能（如日志、推荐）临时关闭，保障主链路。
>
> > 示例（Sentinel）：
>
> ```java
> @SentinelResource(value = "seckill", blockHandler = "handleSeckillBlock")
> public String doSeckill(...) { ... }
> ```
>
> ### 2. **库存一致性保障**
>
> #### 方案 A：Redis 预扣库存 + 异步下单（推荐）
>
> - 秒杀前将库存加载到 Redis（如 `DECR` 原子操作）。
> - 扣减成功后，发送 MQ 消息异步创建订单、扣减 DB 库存。
> - 最终通过定时对账保证 Redis 与 DB 一致性。
>
> > Redis 扣库存 Lua 脚本（原子性）：
>
> ```lua
> local stock = redis.call('GET', KEYS[1])
> if tonumber(stock) > 0 then
>     return redis.call('DECR', KEYS[1])
> else
>     return -1
> end
> ```
>
> #### 方案 B：数据库乐观锁
>
> ```sql
> UPDATE seckill_stock SET stock = stock - 1 
> WHERE item_id = ? AND stock > 0;
> ```
>
> - 适用于并发量相对可控的场景，但 DB 压力大。
>
> #### 方案 C：分布式锁（不推荐用于高并发秒杀）
>
> - 性能差，吞吐量低，仅适合低频场景。
>
> ### 3. **缓存设计防击穿/穿透/雪崩**
>
> - 缓存击穿
>
>   ：热点 key 过期瞬间大量请求打到 DB。
>
>   - 解决：永不过期 + 后台异步更新；或使用互斥锁重建缓存。
>
> - 缓存穿透
>
>   ：查询不存在的商品 ID。
>
>   - 解决：布隆过滤器（Bloom Filter）拦截无效 ID；或缓存空值（带短 TTL）。
>
> - 缓存雪崩
>
>   ：大量 key 同时过期。
>
>   - 解决：设置随机过期时间；多级缓存（本地 + Redis）。
>
> ### 4. **异步化与削峰填谷**
>
> - 使用消息队列（如 RocketMQ / Kafka）将“创建订单”解耦。
> - 用户请求 → Redis 扣库存成功 → 发送 MQ → 后台消费创建订单。
> - 优点：削峰、解耦、提高吞吐量。
>
> > 注意：需处理消息重复消费（幂等性）和失败补偿（死信队列 + 人工干预）。
>
> ### 5. **防刷与安全机制**
>
> - **IP 限流**：Nginx 或网关层限制单 IP 请求频率。
> - **用户行为分析**：同一用户短时间内多次请求，加入黑名单。
> - **验证码**：在秒杀前弹出，过滤机器人。
> - **Token 机制**：秒杀前发放唯一 token，防止 URL 直接访问。
>
> ### 6. **架构分层与动静分离**
>
> - **静态资源 CDN 化**：商品详情页静态化，减少后端压力。
> - **读写分离**：商品信息走缓存，下单走独立服务。
> - **服务隔离**：秒杀服务独立部署，避免影响主站。
>
> ### 7. **压测与监控**
>
> - 使用 JMeter / Gatling 进行全链路压测。
> - 接入 Prometheus + Grafana 监控 QPS、RT、错误率。
> - 日志追踪（SkyWalking / Zipkin）快速定位瓶颈。
>
> ------
>
> ## 三、典型架构流程（简化版）
>
> ```
> 用户 → CDN（静态页） → 网关（限流/鉴权） 
>        → 秒杀服务（校验 token + Redis 扣库存） 
>        → 成功？ → 发送 MQ → 订单服务（异步创建订单 + DB 扣库存）
>                 → 失败？ → 返回“已售罄”
> ```
>
> ------
>
> ## 四、总结
>
> | 难点    | 解决方案                         |
> | ------- | -------------------------------- |
> | 高并发  | 限流、缓存、异步、静态化         |
> | 超卖    | Redis 原子扣减 + MQ 异步 + 对账  |
> | DB 压力 | 缓存前置、读写分离、异步落库     |
> | 安全    | 验证码、Token、IP 限流、布隆过滤 |
> | 稳定性  | 服务隔离、熔断降级、监控告警     |

RabbitMQ怎么做削峰

怎么解决超卖问题

加分布式锁，多把锁？

sentinel怎么做限流的，原理是什么

线程池核心参数有哪些，工作原理

## spring框架中有哪些设计模式，说出五个

> https://juejin.cn/post/7528405614440988726

## JVM核心参数，设置过哪些，说出五个

> JVM（Java Virtual Machine）的核心参数设置对于 Java 应用的性能、稳定性以及资源使用至关重要。以下是常见的 JVM 核心参数分类及说明，适用于 HotSpot 虚拟机（Oracle JDK / OpenJDK）：
>
> ------
>
> ## 一、堆内存相关参数
>
> | 参数                    | 说明                                                       |
> | ----------------------- | ---------------------------------------------------------- |
> | `-Xms<size>`            | 初始堆大小（如 `-Xms2g` 表示初始堆为 2GB）                 |
> | `-Xmx<size>`            | 最大堆大小（如 `-Xmx4g` 表示最大堆为 4GB）                 |
> | `-XX:NewRatio=<n>`      | 老年代与新生代比例（默认 2，即老年代:新生代 = 2:1）        |
> | `-XX:NewSize=<size>`    | 新生代初始大小                                             |
> | `-XX:MaxNewSize=<size>` | 新生代最大大小                                             |
> | `-XX:SurvivorRatio=<n>` | Eden 与 Survivor 区比例（如 8 表示 Eden:Survivor = 8:1:1） |
>
> > **建议**：生产环境通常将 `-Xms` 和 `-Xmx` 设置为相同值，避免运行时动态扩容带来的性能抖动。
>
> ------
>
> ## 二、垃圾回收器（GC）相关参数
>
> ### 常见 GC 类型（Java 8 ~ Java 17）
>
> | GC 类型                               | 启用参数                  | 适用场景                                |
> | ------------------------------------- | ------------------------- | --------------------------------------- |
> | Serial GC                             | `-XX:+UseSerialGC`        | 单核、小内存应用                        |
> | Parallel GC（默认 Java 8）            | `-XX:+UseParallelGC`      | 吞吐量优先（批处理）                    |
> | CMS（已废弃）                         | `-XX:+UseConcMarkSweepGC` | 低延迟（Java 8 中可用，Java 9+ 不推荐） |
> | G1 GC（Java 9+ 默认）                 | `-XX:+UseG1GC`            | 大堆、低延迟要求                        |
> | ZGC（Java 11+ 实验性，Java 15+ 正式） | `-XX:+UseZGC`             | 超大堆（TB 级）、极低停顿（<10ms）      |
> | Shenandoah（OpenJDK 特有）            | `-XX:+UseShenandoahGC`    | 低停顿并发 GC                           |
>
> ### G1 GC 常用调优参数
>
> ```bash
> -XX:+UseG1GC
> -XX:MaxGCPauseMillis=200          # 目标最大 GC 暂停时间（毫秒）
> -XX:G1HeapRegionSize=16m          # Region 大小（1~32MB，需为 2 的幂）
> -XX:G1NewSizePercent=30           # 新生代最小占比（默认 5%）
> -XX:G1MaxNewSizePercent=60        # 新生代最大占比
> -XX:InitiatingHeapOccupancyPercent=45  # 触发并发标记的堆占用阈值（默认 45%）
> ```
>
> ------
>
> ## 三、元空间（Metaspace）参数（Java 8+）
>
> | 参数                                  | 说明                                         |
> | ------------------------------------- | -------------------------------------------- |
> | `-XX:MetaspaceSize=<size>`            | 元空间初始触发 Full GC 的阈值                |
> | `-XX:MaxMetaspaceSize=<size>`         | 元空间最大大小（默认无上限，建议设限防 OOM） |
> | `-XX:CompressedClassSpaceSize=<size>` | 压缩类指针空间大小（默认 1G）                |
>
> > 示例：`-XX:MaxMetaspaceSize=512m`
>
> ------
>
> ## 四、JIT 编译与性能优化
>
> | 参数                          | 说明                            |
> | ----------------------------- | ------------------------------- |
> | `-XX:+TieredCompilation`      | 分层编译（默认开启）            |
> | `-XX:TieredStopAtLevel=1`     | 关闭 JIT 优化（调试用）         |
> | `-XX:+UseStringDeduplication` | G1 下启用字符串去重（节省内存） |
>
> ------
>
> ## 五、诊断与监控参数
>
> | 参数                                   | 说明                          |
> | -------------------------------------- | ----------------------------- |
> | `-XX:+PrintGC`                         | 打印 GC 基本信息              |
> | `-XX:+PrintGCDetails`                  | 打印详细 GC 日志              |
> | `-XX:+PrintGCTimeStamps`               | GC 日志带时间戳               |
> | `-Xloggc:<file>`                       | 指定 GC 日志输出文件          |
> | `-XX:+HeapDumpOnOutOfMemoryError`      | OOM 时自动生成堆转储          |
> | `-XX:HeapDumpPath=/path/to/dump.hprof` | 指定堆转储路径                |
> | `-XX:+UseGCLogFileRotation`            | GC 日志轮转（需配合下面参数） |
> | `-XX:NumberOfGCLogFiles=5`             | 日志文件数量                  |
> | `-XX:GCLogFileSize=100M`               | 单个日志文件大小              |
>
> > Java 9+ 使用统一日志系统：
> >
> > ```bash
> > -Xlog:gc*:file=gc.log:time,tags
> > ```
>
> ------
>
> ## 六、典型生产环境 JVM 参数示例（Java 8 + G1）
>
> ```bash
> java -server \
>   -Xms4g \
>   -Xmx4g \
>   -XX:+UseG1GC \
>   -XX:MaxGCPauseMillis=200 \
>   -XX:G1HeapRegionSize=16m \
>   -XX:MaxMetaspaceSize=512m \
>   -XX:+HeapDumpOnOutOfMemoryError \
>   -XX:HeapDumpPath=/logs/heapdump.hprof \
>   -XX:+PrintGCDetails \
>   -XX:+PrintGCTimeStamps \
>   -Xloggc:/logs/gc.log \
>   -XX:+UseGCLogFileRotation \
>   -XX:NumberOfGCLogFiles=5 \
>   -XX:GCLogFileSize=100M \
>   -jar your-app.jar
> ```
>
> ------
>
> ## 七、注意事项
>
> 1. **不要盲目调大堆内存**：过大的堆会增加 GC 停顿时间（尤其非 ZGC/Shenandoah）。
> 2. **监控是调优的前提**：结合 GC 日志、APM 工具（如 Prometheus + Grafana、Arthas、VisualVM）分析。
> 3. **容器化环境注意**：JVM 可能无法正确识别容器内存限制（Java 10+ 支持 `-XX:+UseContainerSupport`，默认开启）。
> 4. **Java 版本差异**：不同 JDK 版本默认 GC 和参数行为可能不同（如 Java 8 默认 Parallel，Java 11 默认 G1）。

## JVM内存和线程数之间的关系，4C 8G，线程数多少

> 1. JVM 的**线程数**与**内存配置**（尤其是堆外内存）密切相关。在 **4核8G** 的服务器上，能创建多少线程，主要取决于以下几个关键因素：
>
>    ------
>
>    ## 一、线程内存消耗原理
>
>    每个 Java 线程都会在**操作系统本地内存（Native Memory）\**中分配一个\**线程栈（Thread Stack）**，其大小由 JVM 参数 `-Xss` 控制。
>
>    - 默认-Xss值：
>      - Linux 64位：**1MB**
>      - Windows：**约 1MB**
>      - 某些容器环境或调优后可能设为 **256KB ~ 512KB**
>
>    > ⚠️ 注意：线程栈**不在堆内存（-Xmx）中**，而是在**堆外内存（Native Memory）**中分配。
>
>    ------
>
>    ## 二、理论最大线程数估算公式
>
>    ```tex
>    最大线程数 ≈ (系统可用内存 - JVM堆内存 - 元空间 - 其他Native开销) / 每个线程栈大小（-Xss）
>    ```
>
>    ### 以 4C8G 为例（总物理内存 = 8GB）
>
>    假设典型生产配置：
>
>    - `-Xmx = 4g`（堆最大 4GB）
>    - `-XX:MaxMetaspaceSize = 512m`
>    - 其他 Native 开销（CodeCache、Direct Buffer、JNI 等）≈ **512MB**
>    - 系统保留内存（OS + 其他进程）≈ **1GB**
>
>    则可用于线程栈的内存 ≈
>     `8GB - 4GB - 0.5GB - 0.5GB - 1GB = 2GB`
>
>    ### 不同 `-Xss` 下的线程数上限：
>
>    | `-Xss` 设置 | 每线程栈大小 | 可用栈内存（2GB） | 理论最大线程数  |
>    | ----------- | ------------ | ----------------- | --------------- |
>    | 默认 1MB    | 1 MB         | 2048 MB           | **≈ 2000 线程** |
>    | 512KB       | 0.5 MB       | 2048 MB           | **≈ 4000 线程** |
>    | 256KB       | 0.25 MB      | 2048 MB           | **≈ 8000 线程** |
>
>    > ✅ 实际能创建的线程数通常略低于理论值，因还有 TCB（线程控制块）、内核结构等额外开销。
>
>    ------
>
>    ## 三、操作系统限制
>
>    即使内存足够，操作系统也有硬性限制：
>
>    - Linux
>
>      ：
>
>      - 单进程最大线程数：`/proc/sys/kernel/threads-max`（通常几万）
>      - 用户级限制：`ulimit -u`（nproc，影响总线程数）
>      - PID 上限：`/proc/sys/kernel/pid_max`
>
>    可通过以下命令查看当前 Java 进程的线程数：
>
>    ```bash
>    # 查看某 Java 进程的线程数
>    ps -T -p <pid> | wc -l
>    
>    # 或
>    top -H -p <pid>
>    ```
>
>    ------
>
>    ## 四、实际建议（4C8G 场景）
>
>    | 场景                                    | 推荐做法                                                     |
>    | --------------------------------------- | ------------------------------------------------------------ |
>    | **Web 应用（如 Spring Boot + Tomcat）** | 使用线程池，**maxThreads ≤ 500~800**（避免资源耗尽） 配合异步（CompletableFuture / WebFlux）提升并发 |
>    | **高 IO 并发（如网关、消息处理）**      | 考虑 **虚拟线程（Java 21+ Virtual Threads）**，可轻松支持数万并发 |
>    | **传统多线程任务**                      | 显式使用 `ThreadPoolExecutor`，**核心线程数 = CPU 核数（4）**，最大线程数根据任务类型调整（IO 密集型可设更高） |
>
>    > 🔧 **推荐 JVM 参数（4C8G）**：
>
>    
>
>    ```bash
>    -Xms4g -Xmx4g \
>    -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m \
>    -Xss256k \                     # 减小栈大小，支持更多线程（需测试无 StackOverflowError）
>    -XX:+UseG1GC \
>    -XX:MaxGCPauseMillis=200
>    ```
>
>    > 💡 若应用是 **IO 密集型**（如 HTTP 调用、DB 查询），线程大部分时间在等待，可适当增加线程池大小（如 200~500）。
>    >  若是 **CPU 密集型**，线程数应接近 CPU 核数（4~8），避免上下文切换开销。
>
>    ------
>
>    ## 五、OOM 风险提示
>
>    若无限制创建线程（如 `new Thread().start()` 循环），极易触发：
>
>    ```java
>    java.lang.OutOfMemoryError: unable to create new native thread
>    ```
>
>    ✅ **解决方案**：
>
>    - 使用**线程池**（`Executors` / `ThreadPoolExecutor`）
>    - 监控线程数（通过 JMX、Arthas、Prometheus）
>    - 合理设置 `-Xss`（但不能太小，否则 `StackOverflowError`）
>
>    ------
>
>    ## 总结（4C8G）
>
>    | 项目                           | 建议值                                                       |
>    | ------------------------------ | ------------------------------------------------------------ |
>    | **最大安全线程数（传统线程）** | **500 ~ 2000**（取决于 `-Xss` 和业务）                       |
>    | **推荐 `-Xss`**                | **256k ~ 512k**（平衡线程数与栈深度）                        |
>    | **堆内存**                     | **4g**（留足 Native 内存给线程和其他组件）                   |
>    | **更优方案**                   | **Java 21+ 虚拟线程**（Project Loom），可轻松支持 10,000+ 并发 |
>
>    > 📌 **不要追求“最大线程数”，而要追求“合理并发模型”** —— 异步、响应式、协程才是高并发的未来。




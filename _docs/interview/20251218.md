20251218

17:00～18：00 作业帮 拉新业务

自我介绍聊项目

为什么选择换工作、作业帮那边技术栈golang和php为主能不能接受、和之前做的业务不一样、对业务感不感兴趣

财富Alpha+平台数据侧

对招行App C端输出场景，QPS多少

介绍UI自动化平台、和现有的UI自动化框架有什么区别

> 回答和BrowserUse做了对比：
>
> 1. 对基础组件进行封装，组件高度复用，可以通过拖拽的形式实现复杂工作流，在基础组件基础上封装常用组件并复用；
> 2. BrowserUse执行比较黑盒，goodui支持工作流中的单组件调试，实现了AOP日志增强，方便调试；
> 3. 准确性方面：goodui通过DOM剪枝算法、多模态视觉理解、RAG召回领域知识等方式，在自然语言转脚本工作流、AI元素定位准确率上，效果更好，更准确。

八股文：

覆盖索引和非覆盖索引

B树、B+树、二叉树区别，为什么选择B+树

如何定位慢查询、怎么解决

explain查看执行计划，返回的结果中extra字段还记不记得

Redis为什么快

redis集群怎么保证高可用

算法题：

```
运用所掌握的数据结构，设计和实现一个  LRU (Least Recently Used，最近最少使用) 缓存机制 
   实现 GET 和 PUT 方法
```

如下：

![image-20251218201104753](image-20251218201104753.png)

写出来了没跑测试用例，代码如下：

```java
import java.util.*;

class LRUCache {
    class Node {
        int key;
        int value;
        Node prev;
        Node next;
        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    Map<Integer, Node> cache = new HashMap<>();
    int capacity;
    Node dummy = new Node(0, 0);

    public LRUCache(int capacity) {
        this.capacity = capacity;
        dummy.prev = dummy;
        dummy.next = dummy;
    }

    public Node get(int key) {
        Node node = getNode(key);
        return node;
    }

    public void put(int key, int value) {
        Node node = getNode(key);
        if(node == null) {
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            if(cache.size() > capacity) {
                removeNode(dummy.prev);
            }
        } else {
            node.value = value;
        }
    }

    public Node getNode(int key) {
        if(!cache.containsKey(key)) {
            return null;
        }
        Node node = cache.get(key);
        insertHead(node);
        return node;
    }

    private void insertHead(Node node) {
        Node temp = dummy.next;
        dummy.next = node;
        dummy.next.prev = node;
        node.prev = dummy;
        node.next = temp;
    }

    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
}
```

